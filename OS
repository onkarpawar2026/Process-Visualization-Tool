import React, { useState, useEffect } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
import { motion } from "framer-motion";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
  LabelList,
  Cell
} from "recharts";

const states = ["New", "Ready", "Running", "Waiting", "Terminated"];
const transitions = {
  New: "Ready",
  Ready: "Running",
  Running: ["Waiting", "Terminated"],
  Waiting: "Ready",
};

const ProcessState = ({ currentState }) => {
  return (
    <div className="flex gap-4 justify-center flex-wrap mt-4">
      {states.map((state) => (
        <motion.div
          key={state}
          className={`p-4 rounded-2xl text-white shadow-lg w-36 text-center ${
            currentState === state ? "bg-blue-500" : "bg-gray-700"
          }`}
          whileHover={{ scale: 1.05 }}
        >
          {state}
        </motion.div>
      ))}
    </div>
  );
};

const colorMap = {};
const getColor = (name) => {
  if (!colorMap[name]) {
    colorMap[name] = "#" + ((Math.random() * 0xffffff) << 0).toString(16).padStart(6, "0");
  }
  return colorMap[name];
};

const GanttChart = ({ algorithm, processes }) => {
  const simulateScheduling = (algorithm) => {
    let timeline = [];
    let queue = [...processes];
    let time = 0;

    switch (algorithm) {
      case "FCFS":
        queue.sort((a, b) => a.arrival - b.arrival);
        queue.forEach((p) => {
          if (time < p.arrival) time = p.arrival;
          timeline.push({ name: p.name, start: time, duration: p.burst });
          time += p.burst;
        });
        break;
      case "SJF":
        let sjfQueue = [];
        let arrived = [];
        while (queue.length > 0 || arrived.length > 0) {
          queue = queue.filter((p) => {
            if (p.arrival <= time) {
              arrived.push(p);
              return false;
            }
            return true;
          });
          arrived.sort((a, b) => a.burst - b.burst);
          if (arrived.length === 0) {
            time++;
            continue;
          }
          let p = arrived.shift();
          timeline.push({ name: p.name, start: time, duration: p.burst });
          time += p.burst;
        }
        break;
      case "Priority":
        let prioQueue = [];
        while (queue.length > 0 || prioQueue.length > 0) {
          queue = queue.filter((p) => {
            if (p.arrival <= time) {
              prioQueue.push(p);
              return false;
            }
            return true;
          });
          prioQueue.sort((a, b) => a.priority - b.priority);
          if (prioQueue.length === 0) {
            time++;
            continue;
          }
          let p = prioQueue.shift();
          timeline.push({ name: p.name, start: time, duration: p.burst });
          time += p.burst;
        }
        break;
      case "RoundRobin":
        const quantum = 2;
        let timeRR = 0;
        let rrQueue = [];
        let pending = [...queue].sort((a, b) => a.arrival - b.arrival);
        let ready = [];

        while (pending.length > 0 || ready.length > 0) {
          while (pending.length > 0 && pending[0].arrival <= timeRR) {
            let p = pending.shift();
            ready.push({ ...p, remaining: p.burst });
          }

          if (ready.length === 0) {
            timeRR = pending[0].arrival;
            continue;
          }

          let p = ready.shift();
          let execTime = Math.min(quantum, p.remaining);
          timeline.push({ name: p.name, start: timeRR, duration: execTime });
          timeRR += execTime;
          p.remaining -= execTime;

          while (pending.length > 0 && pending[0].arrival <= timeRR) {
            let newArrival = pending.shift();
            ready.push({ ...newArrival, remaining: newArrival.burst });
          }

          if (p.remaining > 0) {
            ready.push(p);
          }
        }
        break;
      default:
        return [];
    }

    return timeline;
  };

  const simulated = simulateScheduling(algorithm);

  return (
    <ResponsiveContainer width="100%" height={300}>
      <BarChart
        data={simulated}
        margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
        layout="vertical"
      >
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis type="number" label={{ value: "Time", position: "insideBottomRight", offset: -5 }} />
        <YAxis type="category" dataKey="name" />
        <Tooltip />
        <Legend />
        <Bar dataKey="duration" isAnimationActive={false} barSize={20}>
          {simulated.map((entry, index) => (
            <Cell key={`cell-${index}`} fill={getColor(entry.name)} />
          ))}
          <LabelList dataKey="start" position="insideLeft" />
        </Bar>
      </BarChart>
    </ResponsiveContainer>
  );
};

export default function OSProcessVisualizer() {
  const [currentState, setCurrentState] = useState("New");
  const [algorithm, setAlgorithm] = useState("FCFS");
  const [processes, setProcesses] = useState([
    { name: "P1", arrival: 0, burst: 5, priority: 2 },
    { name: "P2", arrival: 1, burst: 3, priority: 1 },
    { name: "P3", arrival: 2, burst: 8, priority: 3 },
    { name: "P4", arrival: 3, burst: 6, priority: 4 },
  ]);

  const handleInputChange = (index, field, value) => {
    const updated = [...processes];
    updated[index][field] = field === 'name' ? value : parseInt(value);
    setProcesses(updated);
  };

  const addProcess = () => {
    setProcesses([
      ...processes,
      { name: `P${processes.length + 1}`, arrival: 0, burst: 1, priority: 1 },
    ]);
  };

  const nextState = () => {
    const next = transitions[currentState];
    if (!next) return;
    if (Array.isArray(next)) {
      setCurrentState(next[0]);
    } else {
      setCurrentState(next);
    }
  };

  const altTransition = () => {
    const next = transitions[currentState];
    if (Array.isArray(next)) {
      setCurrentState(next[1]);
    }
  };

  return (
    <div className="p-6 max-w-4xl mx-auto bg-gray-900 text-white min-h-screen">
      <h1 className="text-3xl font-bold mb-6 text-center">OS Process Visualization</h1>

      <Tabs defaultValue="lifecycle" className="w-full">
        <TabsList className="flex justify-center mb-6 bg-gray-800 rounded-xl">
          <TabsTrigger value="lifecycle">Process Lifecycle</TabsTrigger>
          <TabsTrigger value="scheduling">Scheduling</TabsTrigger>
        </TabsList>

        <TabsContent value="lifecycle">
          <Card className="bg-gray-800 text-white">
            <CardContent className="pt-6">
              <h2 className="text-xl font-semibold mb-2">Lifecycle</h2>
              <p className="text-sm text-gray-300 mb-2">
                Running – Instructions are being executed.
                <br />
                Waiting/Blocked – Waiting for some event (like I/O).
              </p>
              <ProcessState currentState={currentState} />
              <div className="flex gap-4 justify-center mt-4">
                <button
                  onClick={nextState}
                  className="bg-blue-600 text-white px-4 py-2 rounded-2xl shadow"
                >
                  Next State
                </button>
                {Array.isArray(transitions[currentState]) && (
                  <button
                    onClick={altTransition}
                    className="bg-red-500 text-white px-4 py-2 rounded-2xl shadow"
                  >
                    Alternate Transition
                  </button>
                )}
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="scheduling">
          <Card className="bg-gray-800 text-white">
            <CardContent className="pt-6">
              <h2 className="text-xl font-semibold mb-4">Process Scheduling</h2>
              <div className="mb-4">
                <label className="block text-sm font-medium mb-1">Select Algorithm:</label>
                <select
                  className="border rounded px-3 py-2 w-full max-w-sm bg-gray-700 text-white"
                  value={algorithm}
                  onChange={(e) => setAlgorithm(e.target.value)}
                >
                  <option value="FCFS">First-Come First-Serve (FCFS)</option>
                  <option value="SJF">Shortest Job First (SJF)</option>
                  <option value="RoundRobin">Round Robin</option>
                  <option value="Priority">Priority Scheduling</option>
                </select>
              </div>
              <div className="grid grid-cols-4 gap-2 font-semibold text-sm text-center mb-2">
                <div>Process</div>
                <div>Arrival Time</div>
                <div>Burst Time</div>
                <div>Priority</div>
              </div>
              <div className="space-y-2 mb-4">
                {processes.map((p, index) => (
                  <div key={index} className="grid grid-cols-4 gap-2">
                    <input
                      type="text"
                      value={p.name}
                      onChange={(e) => handleInputChange(index, "name", e.target.value)}
                      className="border rounded px-2 py-1 bg-gray-700 text-white"
                      placeholder="Name"
                    />
                    <input
                      type="number"
                      value={p.arrival}
                      onChange={(e) => handleInputChange(index, "arrival", e.target.value)}
                      className="border rounded px-2 py-1 bg-gray-700 text-white"
                      placeholder="Arrival Time"
                    />
                    <input
                      type="number"
                      value={p.burst}
                      onChange={(e) => handleInputChange(index, "burst", e.target.value)}
                      className="border rounded px-2 py-1 bg-gray-700 text-white"
                      placeholder="Burst Time"
                    />
                    <input
                      type="number"
                      value={p.priority}
                      onChange={(e) => handleInputChange(index, "priority", e.target.value)}
                      className="border rounded px-2 py-1 bg-gray-700 text-white"
                      placeholder="Priority"
                    />
                  </div>
                ))}
                <button
                  onClick={addProcess}
                  className="mt-2 bg-green-600 text-white px-4 py-2 rounded shadow"
                >
                  Add Process
                </button>
              </div>
              <GanttChart algorithm={algorithm} processes={processes} />
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}
 
    
  
